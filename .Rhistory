panel.grid.major = element_blank (),
panel.grid.minor = element_blank (),
plot.background = element_blank (),
axis.line = element_line(size = 0.5, linetype = "solid", color = "black"),
axis.ticks = element_line(size = 0.5, linetype = "solid", color = "black"),
legend.position = "none")}
bootstrap <- 10000 #number of bootstraps
permutations <- 99999 #number of permutations
rubble_types <- 3 #number of different rubble types in the experiment
substratum_types <- 4 #number of substratum types from coralnet
settlement_day <- 6 #day chosen for the settlement electivity calculations
mortality_start <- 12 #first day to fit mortality rate to
mortality_end <- 26 #last day to fit mortality rate to
settlement_counts <- read_csv("settlement_counts.csv",
col_types = cols(day = col_double(),
container = col_character(),
rubble_type = col_character(),
position = col_character(),
bt = col_double(),
ct = col_double(),
rt = col_double(),
ot = col_double(),
bs = col_double(),
cs = col_double(),
rs = col_double(),
os = col_double(),
bb = col_double(),
cb = col_double(),
rb = col_double(),
ob = col_double())) #number of corals on each substratum type each day (raw data)
rubble_area <- read_csv("rubble_area.csv",
col_types = cols(container = col_character(),
cca = col_double(),
bare = col_double(),
ram = col_double())) #calculated area of each rubble (from data prep)
patch_type_area <- read_csv("patch_type_area.csv",
col_types = cols(container = col_double(),
bare = col_double(),
cca = col_double(),
ram = col_double(),
spon = col_double())) #calculated area of each substratum type in a container (from data prep)
day6_settlement <- settlement_counts %>%
mutate(bare = bt + bs + bb,
cca = ct + cs + cb,
ram = rt + rs + rb,
spon = ot + os + ob) %>% #add up settlers on each substratum
filter(day == settlement_day) %>% #isolate settlement day data
select(-position:-ob) #remove extra columns
# assemble the data frame to calculate electiviites
# Add a column to get total settlers in each container
rubble_electivity_addTotals <- mutate(day6_settlement, total = bare + cca + ram + spon)
# This just changes the class type so we can use it later
rubble_groupBy <- group_by(rubble_electivity_addTotals, container, rubble_type)
# Arrange data organized by container and rubble type
rubble_summarize <- summarize(rubble_groupBy, total = sum(total))
# Change the shape of the dataframe
rubble_pivot_polypCounts <- pivot_wider(rubble_summarize, names_from = rubble_type, values_from = total)
# Add the rubble_area dataframe so we can use it for electivities
rubble_merge <- merge(rubble_pivot_polypCounts, rubble_area, by = "container")
rubble_merge
library(boot) #load for bootstrapping
library(vegan) #load for PERMANOVA
library(tidyverse)
library(grid)
library(gridExtra)
rm(list =  ls())
graphics.off()
samplemedian <- function(x, d) {return(median(x[d]))} #create a bootstrapping function
electivity_plot <- list(
ylim(-1,1),
geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.5))
electivity_theme <- function(){
theme(axis.title = element_text (size = 10),
axis.text = element_text (size = 10, color = "black"),
panel.background = element_blank (),
panel.grid.major = element_blank (),
panel.grid.minor = element_blank (),
plot.background = element_blank (),
axis.line = element_line(size = 0.5, linetype = "solid", color = "black"),
axis.ticks = element_line(size = 0.5, linetype = "solid", color = "black"),
legend.position = "none")}
bootstrap <- 10000 #number of bootstraps
permutations <- 99999 #number of permutations
rubble_types <- 3 #number of different rubble types in the experiment
substratum_types <- 4 #number of substratum types from coralnet
settlement_day <- 6 #day chosen for the settlement electivity calculations
mortality_start <- 12 #first day to fit mortality rate to
mortality_end <- 26 #last day to fit mortality rate to
settlement_counts <- read_csv("settlement_counts.csv",
col_types = cols(day = col_double(),
container = col_character(),
rubble_type = col_character(),
position = col_character(),
bt = col_double(),
ct = col_double(),
rt = col_double(),
ot = col_double(),
bs = col_double(),
cs = col_double(),
rs = col_double(),
os = col_double(),
bb = col_double(),
cb = col_double(),
rb = col_double(),
ob = col_double())) #number of corals on each substratum type each day (raw data)
rubble_area <- read_csv("rubble_area.csv",
col_types = cols(container = col_character(),
cca = col_double(),
bare = col_double(),
ram = col_double())) #calculated area of each rubble (from data prep)
patch_type_area <- read_csv("patch_type_area.csv",
col_types = cols(container = col_double(),
bare = col_double(),
cca = col_double(),
ram = col_double(),
spon = col_double())) #calculated area of each substratum type in a container (from data prep)
day6_settlement <- settlement_counts %>%
mutate(bare = bt + bs + bb,
cca = ct + cs + cb,
ram = rt + rs + rb,
spon = ot + os + ob) %>% #add up settlers on each substratum
filter(day == settlement_day) %>% #isolate settlement day data
select(-position:-ob) #remove extra columns
# assemble the data frame to calculate electiviites
# Add a column to get total settlers in each container
rubble_electivity_addTotals <- mutate(day6_settlement, total = bare + cca + ram + spon)
# This just changes the class type so we can use it later
rubble_groupBy <- group_by(rubble_electivity_addTotals, container, rubble_type)
# Arrange data organized by container and rubble type
rubble_summarize <- summarize(rubble_groupBy, total = sum(total))
# Change the shape of the dataframe
rubble_pivot_polypCounts <- pivot_wider(rubble_summarize, names_from = rubble_type, values_from = total)
# Add the rubble_area dataframe so we can use it for electivities
rubble_merge <- merge(rubble_pivot_polypCounts, rubble_area, by = "container")
#this chunk calculates electivites...
# function to calculate electivities
get_electivity <- function(counts, areas){
densities <- counts / areas
total_density <- sum(densities)
proportions <- densities / total_density    #i.e. Chesson's alpha
ntypes <- length(counts)
electivities <- (proportions - 1 / ntypes) / (proportions - 1 / ntypes)
return(electivities)
}
# # Calculate proportion of total settlers on each substratum
# rubble_merge_density <- mutate(rubble_merge,
#                              density_bare = bare.x/bare.y,
#                              density_cca = cca.x/cca.y,
#                              density_ram = ram.x/ram.y)
#
# # Add Chesson's alphas
# rubble_alphas <- mutate(rubble_merge_density, bare_a = density_bare / (density_bare + density_cca + density_ram),
#                              cca_a = density_cca / (density_bare + density_cca + density_ram),
#                              ram_a = density_ram / (density_bare + density_cca + density_ram))
# rubble_alphas
#
# # Calculate the electivities
# rubble_electivities <- mutate(rubble_alphas, bare_e = (bare_a - 1 / rubble_types) / (bare_a + 1 / rubble_types),
#                                              cca_e = (cca_a - 1 / rubble_types) / (cca_a + 1 / rubble_types),
#                                              ram_e = (ram_a - 1 / rubble_types) / (ram_a + 1 / rubble_types))
#
# rubble_electivities
counts <- rubble_merge[,2:4]
counts
counts <- rubble_merge[1,2:4]
counts
areas <- rubble_merge[1,5:7]
counts
areas
rubble_merge
counts <- rubble_merge[2,2:4]
areas <- rubble_merge[2,5:7]
counts
areas
out <- get_electivity(counts, areas)
out
# function to calculate electivities
get_electivity <- function(counts, areas){
densities <- counts / areas
total_density <- sum(densities)
proportions <- densities / total_density    #i.e. Chesson's alpha
ntypes <- length(counts)
electivities <- (proportions - 1 / ntypes) / (proportions + 1 / ntypes)
return(electivities)
}
out <- get_electivity(counts, areas = )
out <- get_electivity(counts, areas)
out
counts
areas
names(rubble_merge)
out <- mutate(rubble_merge, elec = get_electivity(counts = c(cca.x, bare.x, ram.x), areas = c(cca.y, bare.y, ram.y)))
i = 1
counts <- c(rubble_merge$cca.x[i], rubble_merge$bare.x[i], rubble_merge$ram.x[i])
counts
areas <- c(rubble_merge$cca.y[i], rubble_merge$bare.y[i], rubble_merge$ram.y[i])
elec <- matrix(NA, 3, 9)
elec[i, ] <- get_electivity(counts, areas)
elec
elec <- matrix(NA, 9, 3)
for(i in 1:9){
counts <- c(rubble_merge$cca.x[i], rubble_merge$bare.x[i], rubble_merge$ram.x[i])
areas <- c(rubble_merge$cca.y[i], rubble_merge$bare.y[i], rubble_merge$ram.y[i])
elec[i, ] <- get_electivity(counts, areas)
}
elec
library(boot) #load for bootstrapping
library(vegan) #load for PERMANOVA
library(tidyverse)
library(grid)
library(gridExtra)
samplemedian <- function(x, d) {return(median(x[d]))} #create a bootstrapping function
electivity_plot <- list(
ylim(-1,1),
geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.5))
electivity_theme <- function(){
theme(axis.title = element_text (size = 10),
axis.text = element_text (size = 10, color = "black"),
panel.background = element_blank (),
panel.grid.major = element_blank (),
panel.grid.minor = element_blank (),
plot.background = element_blank (),
axis.line = element_line(size = 0.5, linetype = "solid", color = "black"),
axis.ticks = element_line(size = 0.5, linetype = "solid", color = "black"),
legend.position = "none")}
bootstrap <- 10000 #number of bootstraps
permutations <- 99999 #number of permutations
rubble_types <- 3 #number of different rubble types in the experiment
substratum_types <- 4 #number of substratum types from coralnet
settlement_day <- 6 #day chosen for the settlement electivity calculations
mortality_start <- 12 #first day to fit mortality rate to
mortality_end <- 26 #last day to fit mortality rate to
library(boot) #load for bootstrapping
library(vegan) #load for PERMANOVA
library(tidyverse)
library(grid)
library(gridExtra)
samplemedian <- function(x, d) {return(median(x[d]))} #create a bootstrapping function
electivity_plot <- list(
ylim(-1,1),
geom_hline(yintercept = 0, linetype = "dashed", color = "black", size = 0.5))
electivity_theme <- function(){
theme(axis.title = element_text (size = 10),
axis.text = element_text (size = 10, color = "black"),
panel.background = element_blank (),
panel.grid.major = element_blank (),
panel.grid.minor = element_blank (),
plot.background = element_blank (),
axis.line = element_line(size = 0.5, linetype = "solid", color = "black"),
axis.ticks = element_line(size = 0.5, linetype = "solid", color = "black"),
legend.position = "none")}
bootstrap <- 10000 #number of bootstraps
permutations <- 99999 #number of permutations
rubble_types <- 3 #number of different rubble types in the experiment
substratum_types <- 4 #number of substratum types from coralnet
settlement_day <- 6 #day chosen for the settlement electivity calculations
mortality_start <- 12 #first day to fit mortality rate to
mortality_end <- 26 #last day to fit mortality rate to
settlement_counts <- read_csv("settlement_counts.csv",
col_types = cols(day = col_double(),
container = col_character(),
rubble_type = col_character(),
position = col_character(),
bt = col_double(),
ct = col_double(),
rt = col_double(),
ot = col_double(),
bs = col_double(),
cs = col_double(),
rs = col_double(),
os = col_double(),
bb = col_double(),
cb = col_double(),
rb = col_double(),
ob = col_double())) #number of corals on each substratum type each day (raw data)
rubble_area <- read_csv("rubble_area.csv",
col_types = cols(container = col_character(),
cca = col_double(),
bare = col_double(),
ram = col_double())) #calculated area of each rubble (from data prep)
patch_type_area <- read_csv("patch_type_area.csv",
col_types = cols(container = col_double(),
bare = col_double(),
cca = col_double(),
ram = col_double(),
spon = col_double())) #calculated area of each substratum type in a container (from data prep)
day6_settlement <- settlement_counts %>%
mutate(bare = bt + bs + bb,
cca = ct + cs + cb,
ram = rt + rs + rb,
spon = ot + os + ob) %>% #add up settlers on each substratum
filter(day == settlement_day) %>% #isolate settlement day data
select(-position:-ob) #remove extra columns
rubble_electivity <- day6_settlement %>%
mutate(total = bare + cca + ram + spon) %>% #get total settlers
group_by(container, rubble_type) %>%
summarize(total = sum(total)) %>% #arrange data organized by container and rubble type
pivot_wider(names_from = rubble_type, values_from = total) %>% #widen the table
merge(., rubble_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y) %>% #calculate proportion of settlers on each substratum # CHECK THIS IS DENSITY?
mutate(bare_a = bare / (bare + cca + ram),
cca_a = cca / (bare + cca + ram),
ram_a = ram / (bare + cca + ram)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / rubble_types) / (bare_a + 1 / rubble_types),
cca_e = (cca_a - 1 / rubble_types) / (cca_a + 1 / rubble_types),
ram_e = (ram_a - 1 / rubble_types) / (ram_a + 1 / rubble_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) %>% #remove extraneous columns
drop_na() #drop na's (the three containers that only have one rubble type)
patch_electivity <- day6_settlement %>%
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon)) %>%
merge(., patch_type_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y,
spon = spon.x/spon.y) %>% #calculate proportion of settlers on each substratum
mutate(bare_a = bare / (bare + cca + ram + spon),
cca_a = cca / (bare + cca + ram + spon),
ram_a = ram / (bare + cca + ram + spon),
spon_a = spon / (bare + cca + ram + spon)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / substratum_types) / (bare_a + 1 / substratum_types),
cca_e = (cca_a - 1 / substratum_types) / (cca_a + 1 / substratum_types),
ram_e = (ram_a - 1 / substratum_types) / (ram_a + 1 / substratum_types),
spon_e = (spon_a - 1 / substratum_types) / (spon_a + 1 / substratum_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) %>% #remove extraneous columns
patch_electivity <- day6_settlement %>%
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon)) %>%
merge(., patch_type_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y,
spon = spon.x/spon.y) %>% #calculate proportion of settlers on each substratum
mutate(bare_a = bare / (bare + cca + ram + spon),
cca_a = cca / (bare + cca + ram + spon),
ram_a = ram / (bare + cca + ram + spon),
spon_a = spon / (bare + cca + ram + spon)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / substratum_types) / (bare_a + 1 / substratum_types),
cca_e = (cca_a - 1 / substratum_types) / (cca_a + 1 / substratum_types),
ram_e = (ram_a - 1 / substratum_types) / (ram_a + 1 / substratum_types),
spon_e = (spon_a - 1 / substratum_types) / (spon_a + 1 / substratum_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) %>% #remove extraneous columns
patch_electivity <- day6_settlement %>%
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon)) %>%
merge(., patch_type_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y,
spon = spon.x/spon.y) %>% #calculate proportion of settlers on each substratum
mutate(bare_a = bare / (bare + cca + ram + spon),
cca_a = cca / (bare + cca + ram + spon),
ram_a = ram / (bare + cca + ram + spon),
spon_a = spon / (bare + cca + ram + spon)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / substratum_types) / (bare_a + 1 / substratum_types),
cca_e = (cca_a - 1 / substratum_types) / (cca_a + 1 / substratum_types),
ram_e = (ram_a - 1 / substratum_types) / (ram_a + 1 / substratum_types),
spon_e = (spon_a - 1 / substratum_types) / (spon_a + 1 / substratum_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) %>% #remove extraneous columns
patch_electivity <- day6_settlement %>%
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon)) %>%
merge(., patch_type_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y,
spon = spon.x/spon.y) %>% #calculate proportion of settlers on each substratum
mutate(bare_a = bare / (bare + cca + ram + spon),
cca_a = cca / (bare + cca + ram + spon),
ram_a = ram / (bare + cca + ram + spon),
spon_a = spon / (bare + cca + ram + spon)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / substratum_types) / (bare_a + 1 / substratum_types),
cca_e = (cca_a - 1 / substratum_types) / (cca_a + 1 / substratum_types),
ram_e = (ram_a - 1 / substratum_types) / (ram_a + 1 / substratum_types),
spon_e = (spon_a - 1 / substratum_types) / (spon_a + 1 / substratum_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) #remove extraneous columns
patch_electivity <- day6_settlement %>%
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon)) %>%
merge(., patch_type_area, by = "container") %>% #add the rubble_area df
mutate(bare = bare.x/bare.y,
cca = cca.x/cca.y,
ram = ram.x/ram.y,
spon = spon.x/spon.y) %>% #calculate proportion of settlers on each substratum
mutate(bare_a = bare / (bare + cca + ram + spon),
cca_a = cca / (bare + cca + ram + spon),
ram_a = ram / (bare + cca + ram + spon),
spon_a = spon / (bare + cca + ram + spon)) %>% #calculate Chesson's alpha
mutate(bare_e = (bare_a - 1 / substratum_types) / (bare_a + 1 / substratum_types),
cca_e = (cca_a - 1 / substratum_types) / (cca_a + 1 / substratum_types),
ram_e = (ram_a - 1 / substratum_types) / (ram_a + 1 / substratum_types),
spon_e = (spon_a - 1 / substratum_types) / (spon_a + 1 / substratum_types)) %>% #calculate electivities
select(ends_with(c("container", "e")), -bare) #remove extraneous columns
View(patch_electivity)
library(tidyverse)
cnet <- read_csv("coralnet_annotations.csv",
col_types = cols(name = col_character(),
rubble_type = col_character(),
side = col_character(),
container = col_character(),
row = col_double(),
column = col_double(),
label = col_character())) #coralnet annotations
size <- read_csv("size_data.csv",
col_types = cols(container = col_character(),
rubble_type = col_character(),
hgt1 = col_double(),
hgt2 = col_double(),
hgt3 = col_double(),
hgt4 = col_double(),
perim_bot1 = col_double(),
perim_bot2 = col_double(),
perim_bot3 = col_double(),
perim_top1 = col_double(),
perim_top2 = col_double(),
perim_top3 = col_double(),
area_bot1 = col_double(),
area_bot2 = col_double(),
area_bot3 = col_double(),
area_top1 = col_double(),
area_top2 = col_double(),
area_top3 = col_double())) #area, perimeter, and heights of all of the rubble
prop <- cnet %>%
group_by(container, rubble_type) %>%
summarize(bare_bot = sum(label == "bb"),
cca_bot = sum(label == "cb"),
ram_bot = sum(label == "rb"),
spon_bot = sum(label == "ob"),
bare_side = sum(label == "bs"),
cca_side = sum(label == "cs"),
ram_side = sum(label == "rs"),
spon_side = sum(label == "os"),
bare_top = sum(label == "bt"),
cca_top = sum(label == "ct"),
ram_top = sum(label == "rt"),
spon_top = sum(label == "ot")) %>% #count how many of each label for each rubble in a container
mutate(total_bot = bare_bot + cca_bot + ram_bot + spon_bot,
total_side = bare_side + cca_side + ram_side + spon_side,
total_top = bare_top + cca_top + ram_top + spon_top, #get total columns
across(c(2:5), .fns = ~./total_bot),
across(c(6:9), .fns = ~./total_side),
across(c(10:13), .fns = ~./total_top)) %>% #get proportions
select(-total_bot, -total_side, -total_top) #remove extra columns
area <- size %>%
mutate(area_bot = rowMeans(select(., area_bot1, area_bot2, area_bot3), na.rm = TRUE), #bottom area
area_top = rowMeans(select(., area_top1, area_top2, area_top3), na.rm = TRUE), #top area
per_bot = rowMeans(select(., perim_bot1, perim_bot2, perim_bot3), na.rm = TRUE), #perim of bottom
per_top = rowMeans(select(., perim_top1, perim_top2, perim_top3), na.rm = TRUE), #perim of top
height = rowMeans(select(., hgt1, hgt2, hgt3, hgt4), na.rm = TRUE)) %>% #height
mutate(area_side = height * rowMeans(select(., per_bot, per_top)), #side area
area_total = area_bot + area_top + area_side) %>% #total area
select(-per_bot, -per_top, -height, -ends_with(c("1", "2", "3", "4"))) #remove extra columns
container_area <- area %>%
select(c("container", "area_total")) %>% #only use two of the columns
group_by(container) %>%
summarize(area = sum(area_total)) #group by container and add all areas together
rubble_area <- area %>%
select(c("container", "rubble_type", "area_total")) %>% #only keep a few columns
merge(., container_area, by = "container") %>% #give a total area for each container
mutate(area_total = area_total / area) %>% #and then divide each rubble area to get proportion
select(-area) %>% #remove the total area column
pivot_wider(names_from = rubble_type, values_from = area_total, )
patch_type_area <- prop %>%
merge(., area, by = c("container", "rubble_type")) %>% #merge the dataframes
select(ends_with(c("container", "type", "bot", "top", "side", "total"))) %>% #cut out a lot of columns
mutate(bare_bot = bare_bot * area_bot,
cca_bot = cca_bot * area_bot,
ram_bot = ram_bot * area_bot,
spon_bot = spon_bot * area_bot,
bare_side = bare_side * area_side,
cca_side = cca_side * area_side,
ram_side = ram_side * area_side,
spon_side = spon_side * area_side,
bare_top = bare_top * area_top,
cca_top = cca_top * area_top,
ram_top = ram_top * area_top,
spon_top = spon_top * area_top) %>% #find area of each substratum type
mutate(bare = bare_bot + bare_side + bare_top,
cca = cca_bot + cca_side + cca_top,
ram = ram_bot + ram_side + ram_top,
spon = spon_bot + spon_side + spon_top) %>% #find total area for each type
group_by(container) %>%
summarize(bare = sum(bare),
cca = sum(cca),
ram = sum(ram),
spon = sum(spon),
total = sum(area_total)) %>% #add rubble together
mutate(across(c(2:5), .fns = ~./total)) %>% #divide areas by total
select(-total) %>% #remove total column
mutate(bare = replace(bare, bare == 0, 0.000000001),
cca = replace(cca, cca == 0, 0.000000001),
ram = replace(ram, ram == 0, 0.000000001),
spon = replace(spon, spon == 0, 0.000000001)) #replace 0's with extremely small number for electivity calculations
write_csv(rubble_area, "rubble_area.csv") #export the rubble area df
write_csv(patch_type_area, "patch_type_area.csv") #export the patch type area df
